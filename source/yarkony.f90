! YARKONY ROUTINES: THESE MAY BE FOUND IN UTILITIES.COL.F

SUBROUTINE EVB(A,B,C,NB,NC)
implicit none
integer,intent(in)                          :: NB,NC
real*8,dimension(NC),intent(inout):: A
real*8,dimension(NB),intent(in)   :: B
real*8,dimension(NB,NC),intent(in):: C
integer                                     :: i,j

do i = 1,NC
 A(i) = 0.
 do j = 1,NB
  A(i) = A(i) + B(j)*C(j,i)
 end do
end do

return
end SUBROUTINE EVB
!
! EBCT multiplies B and the transpose of C and puts the resulting matrix in A
!
SUBROUTINE EBCT(A,B,C,NI,NK,NJ)
integer     			        :: NI,NK,NJ
real*8,dimension(NI,NJ)	:: A
real*8,dimension(NI,NK)	:: B
real*8,dimension(NJ,NK)	:: C

CALL setmatrix(A,NI,NJ,0)

DO I=1,NI
   DO J=1,NJ
      T=0.0D+00
      DO K=1,NK
         T=T+B(I,K)*C(J,K)
      ENDDO
         A(I,J)=T
   ENDDO
ENDDO

RETURN
END SUBROUTINE EBCT
!
! EBTC multiplies the transpose of B by C and puts the reuslting matrix in A
!
SUBROUTINE EBTC(A,B,C,NI,NK,NJ)
  integer     			:: NI,NK,NJ
  real*8,dimension(NI,NJ)	:: A
  real*8,dimension(NK,NI)	:: B
  real*8,dimension(NK,NJ)	:: C

  CALL setmatrix(A,NI,NJ,0)

  DO I=1,NI
     DO J=1,NJ
        T=0.0D+00
        DO K=1,NK
           T=T+B(K,I)*C(K,J)
        ENDDO
        A(I,J)=T
     ENDDO
  ENDDO

  RETURN
END SUBROUTINE EBTC
!
! EBC multiplies B by C and puts the resulting matrix in A 
!
SUBROUTINE EBC(A,B,C,NI,NK,NJ)
  integer     			:: NI,NK,NJ
  real*8,dimension(NI,NJ)	:: A
  real*8,dimension(NI,NK)	:: B
  real*8,dimension(NK,NJ)	:: C

  CALL setmatrix(A,NI,NJ,0)

  DO I=1,NI
     DO J=1,NJ
        T=0.0D+00
        DO K=1,NK
           T=T+B(I,K)*C(K,J)
        ENDDO
        A(I,J)=T
     ENDDO
  ENDDO
  RETURN
END SUBROUTINE EBC
!
!
!
SUBROUTINE GIVENS (NX,NROOTX,NJX,A,B,ROOT,VECT)
!    real*8 VERSION BY MEL LEVY 8/72
!62.3  GIVENS  -EIGENVALUES AND EIGENVECTORS BY THE GIVENS METHOD.
!    BY FRANKLIN PROSSER, INDIANA UNIVERSITY.
!    SEPTEMBER, 1967
!    CALCULATES EIGENVALUES AND EIGENVECTORS OF REAL SYMMETRI!MATRIX
!    STORED IN PACKED UPPER TRIANGULAR FORM.
!
!    THANKS ARE DUE TO F. E. HARRIS (STANFORD UNIVERSITY) AND H. H.
!    MICHELS (UNITED AIRCRAFT RESEARCH LABORATORIES) FOR EXCELLENT
!    WORK ON NUMERICAL DIFFICULTIES WITH EARLIER VERSIONS OF THIS
!    PROGRAM.
!
!    THE PARAMETERS FOR THE ROUTINE ARE...
!        NX     ORDER OF MATRIX
!        NROOTX NUMBER OF ROOTS WANTED.  THE NROOTX SMALLEST (MOST
!                NEGATIVE) ROOTS WILL BE CALCULATED.  IF NO VECTORS
!                ARE WANTED, MAKE THIS NUMBER NEGATIVE.
!        NJX    ROW DIMENSION OF VECT ARRAY.  SEE -VECT- BELOW.
!                NJX MUST BE NOT LESS THAN NX.
!        A      MATRIX STORED BY COLUMNS IN PACKED UPPER TRIANGULAR
!               FORM, I.E. OCCUPYING NX*(NX+1)/2 CONSECUTIVE
!               LOCATIONS.
!        B      SCRATCH ARRAY USED BY GIVENS.  MUST BE AT LEAST
!                NX*5 CELLS.
!        ROOT   ARRAY TO HOLD THE EIGENVALUES.  MUST BE AT LEAST
!               NROOTX CELLS LONG.  THE NROOTX SMALLEST ROOTS ARE
!                ORDERED LARGEST FIRST IN THIS ARRAY.
!        VECT   EIGENVECTOR ARRAY.  EACH COLUMN WILL HOLD AN
!                EIGENVECTOR FOR THE CORRESPONDING ROOT.  MUST BE
!                DIMENSIONED WITH -NJX- ROWS AND AT LEAST -NROOTX-
!                COLUMNS, UNLESS NO VECTORS
!                ARE REQUESTED (NEGATIVE NROOTX).  IN THIS LATTER
!                CASE, THE ARGUMENT VECT IS JUST A DUMMY, AND THE
!                STORAGE IS NOT USED.
!                THE EIGENVECTORS ARE NORMALIZED TO UNITY.
!
!    THE ARRAYS A AND B ARE DESTROYED BY THE COMPUTATION.  THE RESULTS
!    APPEAR IN ROOT AND VECT.
!    FOR PROPER FUNCTIONING OF THIS ROUTINE, THE RESULT OF A FLOATING
!    POINT UNDERFLOW SHOULD BE A ZERO.
!    TO CONVERT THIS ROUTINE TO real*8 (E.G. ON IBM 360
!    MACHINES), BE SURE THAT ALL REAL VARIABLES AND function
!    REFERENCES ARE PROPERLY MADE real*8.
!    THE VALUE OF -ETA- (SEE BELOW) SHOULD ALSO BE CHANGED, TO REFLECT
!    THE INCREASED PRECISION.
!
!    THE ORIGINAL REFERENCE TO THE GIVENS TECHNIQUE IS IN OAK RIDGE
!    REPORT NUMBER ORNL 1574 (PHYSICS), BY WALLACE GIVENS.
!    THE METHOD AS PRESENTED IN THIS PROGRAM CONSISTS OF FOUR STEPS,
!    ALL MODIFICATIONS OF THE ORIGINAL METHOD...
!    FIRST, THE INPUT MATRIX IS REDUCED TO TRIDIAGONAL FORM BY THE
!    HOUSEHOLDER TECHNIQUE (J. H. WILKINSON, COMP. J. 3, 23 (1960)).
!    THE ROOTS ARE THEN LOCATED BY THE STURM SEQUENCE METHOD (J. M.
!    ORTEGA (SEE REFERENCE BELOW).  THE VECTORS OF THE TRIDIAGONAL
!    FORM ARE THEN EVALUATED (J. H. WILKINSON, COMP. J. 1, 90 (1958)),
!    AND LAST THE TRIDIAGONAL VECTORS ARE ROTATED TO VECTORS OF THE
!    ORIGINAL ARRAY (FIRST REFERENCE).
!    VECTORS FOR DEGENERATE (OR NEAR-DEGENERATE) ROOTS ARE FORCED
!    TO BE ORTHOGONAL, USING A METHOD SUGGESTED BY B. GARBOW, ARGONNE
!    NATIONAL LABS (PRIVATE COMMUNICATION, 1964).  THE GRAM-SCHMIDT
!    PROCESS IS USED FOR THE ORTHOGONALIZATION.
!
!    AN EXCELLENT PRESENTATION OF THE GIVENS TECHNIQUE IS FOUND IN
!    J. M. ORTEGA-S ARTICLE IN -MATHEMATICS FOR DIGITAL COMPUTERS,-
!    VOLUME 2, ED. BY RALSTON AND WILF, WILEY (1967), PAGE 94.
!
    use progdata, only: epsilon
    IMPLICIT REAL*8 (A-H,O-Z)
    real*8 B(NX,5),A(1),ROOT(NROOTX),VECT(NJX,NROOTX)
    real*8 ETA,THETA,DEL1,DELTA,SMALL,DELBIG,THETA1,TOLER
    real*8 RPOWER,RPOW1,RAND1,FACTOR,ANORM,ALIMIT,SUM,TEMP
    real*8 AK,ROOTL,ROOTX,TRIAL,F0,SAVE,AROOT
    real*8 ELIM1,ELIM2
!
!** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!**  USERS PLEASE NOTE...
!**  THE FOLLOWING TWO PARAMETERS, ETA AND THETA, SHOULD BE ADJUSTED
!**  BY THE USER FOR HIS PARTICULAR MACHINE.
!**  ETA IS AN INDICATION OF THE PRECISION OF THE FLOATING POINT
!**  REPRESENTATION ON THE COMPUTER BEING USED (ROUGHLY 10**(-M),
!**  WHERE M IS THE NUMBER OF DECIMALS OF PRECISION ).
!**  THETA IS AN INDICATION OF THE RANGE OF NUMBERS THAT CAN BE
!**  EXPRESSED IN THE FLOATING POINT REPRESENTATION (ROUGHLY THE
!**  LARGEST NUMBER).
!**  SOME RECOMMENDED VALUES FOLLOW.
!**  FOR IBM 7094, UNIVA!1108, ETC. (27-BIT BINARY FRACTION, 8-BIT
!**  BINARY EXPONENT), ETA=1.E-8, THETA=1.E37.
!**  FOR CONTROL DATA 3600 (36-BIT BINARY FRACTION, 11-BIT BINARY
!**  EXPONENT), ETA=1.E-11, THETA=1.E307.
!**  FOR CONTROL DATA 6600 (48-BIT BINARY FRACTION, 11-BIT BINARY
!**  EXPONENT), ETA=1.E-14, THETA=1.E307.
!**  FOR IBM 360/50 AND 360/65 real*8 (56-BIT HEXADECIMAL
!**  FRACTION, 7-BIT HEXADECIMAL EXPONENT), ETA=1.E-16, THETA=1.E75.
!**
    THETA = huge(ELIM1)
    ETA = epsilon
!** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
!
    DEL1=ETA/100.0D0
    DELTA=ETA**2*100.0D0
    SMALL=ETA**2/100.0D0
    DELBIG=THETA*DELTA/1000.0D0
    THETA1=1000.0D0/THETA
!    TOLER  IS A FACTOR USED TO DETERMINE IF TWO ROOTS ARE CLOSE
!    ENOUGH TO BE CONSIDERED DEGENERATE FOR PURPOSES OF ORTHOGONALI-
!    ZING THEIR VECTORS.  FOR THE MATRIX NORMED TO UNITY, IF THE
!    DIFFERENCE BETWEEN TWO ROOTS IS LESS THAN TOLER, THEN
!    ORTHOGONALIZATION WILL OCCUR.
    TOLER = ETA*100.
!
!    INITIAL VALUE FOR PSEUDORANDOM NUMBER GENERATOR... (2**23)-3
    RPOWER=8388608.0D0
    RPOW1 = RPOWER/2.
    RAND1=RPOWER-3.0D0
!
    N = NX
    NROOT = IABS(NROOTX)
    IF (NROOT.EQ.0) GO TO 1001
    IF (N-1) 1001,1003,105
1003  ROOT(1) = A(1)
    IF(NROOTX .GT. 0)VECT(1,1)=1.0D0
    GO TO 1001
105   CONTINUE
!    NSIZE    NUMBER OF ELEMENTS IN THE PACKED ARRAY
    NSIZE = (N*(N+1))/2
    NM1 = N-1
    NM2 = N-2
!
!    SCALE MATRIX TO EUCLIDEAN NORM OF 1.  SCALE FACTOR IS ANORM.
    FACTOR=0.0D-0
    DO 70 I=1,NSIZE
70   FACTOR=DMAX1(FACTOR,DABS(A(I)))
    IF(FACTOR .NE. 0.0D0)GO TO 72
!    NULL MATRIX.  FIX UP ROOTS AND VECTORS, THEN EXIT.
    DO 78 I=1,NROOT
         IF (NROOTX.LT.0) GO TO 78
         DO 77 J=1,N
77        VECT(J,I)=0.0D0
         VECT(I,I)=1.0D0
78   ROOT(I)=0.0D0
    GO TO 1001
!
72   ANORM=0.0D0
    J = 1
    K = 1
    DO 80 I=1,NSIZE
         IF (I.NE.J) GO TO 81
         ANORM=ANORM+(A(I)/FACTOR)**2/2.0D0
         K = K+1
         J = J+K
         GO TO 80
81         ANORM = ANORM + (A(I)/FACTOR)**2
80    CONTINUE
    ANORM=DSQRT(ANORM*2.0D0)*FACTOR
    DO 91 I=1,NSIZE
91    A(I) = A(I)/ANORM
    ALIMIT=1.0D-0
!
!    TRIDIA SECTION.
!    TRIDIAGONALIZATION OF SYMMETRIC MATRIX
    ID = 0
    IA = 1
    IF (NM2.EQ.0) GO TO 201
    DO 200  J=1,NM2
!    J       COUNTS ROW  OF A-MATRIX TO BE DIAGONALIZED
!    IA      START OF NON-CODIAGONAL ELEMENTS IN THE ROW
!    ID      INDEX OF CODIAGONAL ELEMENT ON ROW BEING CODIAGONALIZED.
         IA = IA+J+2
         ID = ID + J + 1
         JP2 = J+2
!    SUM SQUARES OF NON-CODIAGONAL ELEMENTS IN ROW J
         II = IA
         SUM=0.0D-0
         DO 100 I=JP2,N
              SUM = SUM + A(II)**2
100        II = II + I
         TEMP = A(ID)
         IF (SUM.GT.SMALL) GO TO 110
!    NO TRANSFORMATION NECESSARY IF ALL THE NON-CODIAGONAL
!    ELEMENTS ARE TINY.
         B(J,1) = TEMP
         A(ID)=0.0D0
         GO TO 200
!    NOW COMPLETE THE SUM OF OFF-DIAGONAL SQUARES
110       SUM=DSQRT(SUM+TEMP**2)
!    NEW CODIAGONAL ELEMENT
         B(J,1)=-DSIGN(SUM,TEMP)
!    FIRST NON-ZERO ELEMENT OF THIS W-VECTOR
         B(J+1,2)=DSQRT((1.0D0+DABS(TEMP)/SUM)/2.0D0)
!    FORM REST OF THE W-VECTOR ELEMENTS
         TEMP=DSIGN(0.5D0/(B(J+1,2)*SUM),TEMP)
         II = IA
         DO 130 I=JP2,N
              B(I,2) = A(II)*TEMP
130        II = II + I
!    FORM P-VECTOR AND SCALAR.  P-VECTOR = A-MATRIX*W-VECTOR.
!    SCALAR = W-VECTOR*P-VECTOR.
         AK=0.0D0
!    IC      LOCATION OF NEXT DIAGONAL ELEMENT
         IC = ID + 1
         J1 = J + 1
         DO 190  I=J1,N
              JJ = IC
              TEMP=0.0D0
              DO 180  II=J1,N
!    I       RUNS OVER THE NON-ZERO P-ELEMENTS
!    II      RUNS OVER ELEMENTS OF W-VECTOR
                   TEMP = TEMP + B(II,2)*A(JJ)
!    CHANGE INCREMENTING MODE AT THE DIAGONAL ELEMENTS.
                   IF (II.LT.I) GO TO 210
                   JJ = JJ + II
                   GO TO 180
210                  JJ = JJ + 1
180             CONTINUE
!    BUILD UP THE K-SCALAR (AK)
              AK = AK + TEMP*B(I,2)
              B(I,1) = TEMP
!    MOVE I!TO TOP OF NEXT A-MATRIX -ROW-
190        IC = IC + I
!    FORM THE Q-VECTOR
         DO 150  I=J1,N
150        B(I,1) = B(I,1) - AK*B(I,2)
!    TRANSFORM THE REST OF THE A-MATRIX
!    JJ      START-1 OF THE REST OF THE A-MATRIX
         JJ = ID
!    MOVE W-VECTOR INTO THE OLD A-MATRIX LOCATIONS TO SAVE SPACE
!    I       RUNS OVER THE SIGNIFICANT ELEMENTS OF THE W-VECTOR
         DO 160  I=J1,N
              A(JJ) = B(I,2)
              DO 170  II=J1,I
                   JJ = JJ + 1
170            A(JJ)=A(JJ)-2.0D0*(B(I,1)*B(II,2)+B(I,2)*B(II,1))
160        JJ = JJ + J
200   CONTINUE
!    MOVE LAST CODIAGONAL ELEMENT OUT INTO ITS PROPER PLACE
201   CONTINUE
    B(NM1,1) = A(NSIZE-1)
    A(NSIZE-1)=0.0D-0
!
!    STURM SECTION.
!    STURM SEQUENCE ITERATION TO OBTAIN ROOTS OF TRIDIAGONAL FORM.
!    MOVE DIAGONAL ELEMENTS INTO SECOND N ELEMENTS OF B-VECTOR.
!    THIS IS A MORE CONVENIENT INDEXING POSITION.
!    ALSO, PUT SQUARE OF CODIAGONAL ELEMENTS IN THIRD N ELEMENTS.
    JUMP=1
    DO 320 J=1,N
         B(J,2)=A(JUMP)
         B(J,3) = B(J,1)**2
320   JUMP = JUMP+J+1
    DO 310 I=1,NROOT
310   ROOT(I) = +ALIMIT
    ROOTL = -ALIMIT
!    ISOLATE THE ROOTS.  THE NROOT LOWEST ROOTS ARE FOUND, LOWEST FIRST
    DO 330 I=1,NROOT
!    FIND CURRENT -BEST- UPPER BOUND
         ROOTX = +ALIMIT
         DO 335 J=I,NROOT
335       ROOTX=DMIN1(ROOTX,ROOT(J))
         ROOT(I) = ROOTX
!    GET IMPROVED TRIAL ROOT
500       TRIAL=(ROOTL+ROOT(I))*0.5D0
         IF (TRIAL.EQ.ROOTL.OR.TRIAL.EQ.ROOT(I)) GO TO 330
!    FORM STURM SEQUENCE RATIOS, USING ORTEGA-S ALGORITHM (MODIFIED).
!    NOMTCH IS THE NUMBER OF ROOTS LESS THAN THE TRIAL VALUE.
         NOMTCH=N
         J=1
360        F0 = B(J,2) - TRIAL
370        CONTINUE
         IF(DABS(F0) .LT. THETA1)GO TO 380
         IF(F0 .GE. 0.0D0)NOMTCH=NOMTCH-1
         J = J + 1
         IF (J.GT.N) GO TO 390
!    SINCE MATRIX IS NORMED TO UNITY, MAGNITUDE OF B(J,3) IS LESS THAN
!    ONE, AND SINCE F0 IS GREATER THAN THETA1, OVERFLOW IS NOT POSSIBLE
!    AT THE DIVISION STEP.
         F0 = B(J,2) - TRIAL - B(J-1,3)/F0
         GO TO 370
380        J = J + 2
         NOMTCH = NOMTCH - 1
         IF (J.LE.N) GO TO 360
390        CONTINUE
!    FIX NEW BOUNDS ON ROOTS
         IF (NOMTCH.GE.I) GO TO 540
         ROOTL = TRIAL
         GO TO 500
540        ROOT(I) = TRIAL
         NOM = MIN0(NROOT,NOMTCH)
         ROOT(NOM) = TRIAL
         GO TO 500
330   CONTINUE
!    REVERSE THE ORDER OF THE EIGENVALUES, SINCE CUSTOM DICTATES
!    -LARGEST FIRST-.  THIS SECTION MAY BE REMOVED IF DESIRED WITHOUT
!    AFFECTING THE REMAINDER OF THE ROUTINE.
!    NRT = NROOT/2
!    DO 10 I=1,NRT
!    SAVE = ROOT(I)
!    NMIP1 = NROOT - I + 1
!!   ROOT(I) = ROOT(NMIP1)
!10   ROOT(NMIP1) = SAVE
!
!    TRIVE!SECTION.
!    EIGENVECTORS OF CODIAGONAL FORM
!807  CONTINUE
!    QUIT NOW IF NO VECTORS WERE REQUESTED.
    IF (NROOTX.LT.0) GO TO 1002
!    INITIALIZE VECTOR ARRAY.
    DO 15 I=1,N
         DO 15 J=1,NROOT
15   VECT(I,J)=1.0D-0
    DO 700 I=1,NROOT
         AROOT = ROOT(I)
!    ORTHOGONALIZE IF ROOTS ARE CLOSE.
         IF (I.EQ.1) GO TO 710
!    THE ABSOLUTE VALUE IN THE NEXT TEST IS TO ASSURE THAT THE TRIVEC
!    SECTION IS INDEPENDENT OF THE ORDER OF THE EIGENVALUES.
         IF(DABS(ROOT(I-1)-AROOT) .LT. TOLER)GO TO 720
710        IA = -1
720        IA = IA + 1
         ELIM1 = A(1) - AROOT
         ELIM2 = B(1,1)
         JUMP = 1
         DO 750  J=1,NM1
              JUMP = JUMP+J+1
!    GET THE CORRECT PIVOT EQUATION FOR THIS STEP.
              IF(DABS(ELIM1) .LE. DABS(B(J,1)))GO TO 760
!    FIRST (ELIM1) EQUATION IS THE PIVOT THIS TIME.  CASE 1.
              B(J,2) = ELIM1
              B(J,3) = ELIM2
              B(J,4)=0.0D0
              TEMP = B(J,1)/ELIM1
              ELIM1 = A(JUMP) - AROOT - TEMP*ELIM2
              ELIM2 = B(J+1,1)
              GO TO 755
!    SECOND EQUATION IS THE PIVOT THIS TIME.  CASE 2.
760             B(J,2) = B(J,1)
              B(J,3) = A(JUMP) - AROOT
              B(J,4) = B(J+1,1)
              TEMP=1.0D0
              IF(DABS(B(J,1)) .GT. THETA1)TEMP=ELIM1/B(J,1)
              ELIM1 = ELIM2 - TEMP*B(J,3)
              ELIM2 = -TEMP*B(J+1,1)
!    SAVE FACTOR FOR THE SECOND ITERATION.
755             B(J,5) = TEMP
750        CONTINUE
         B(N,2) = ELIM1
         B(N,3)=0.0D-0
         B(N,4)=0.0D-0
         B(NM1,4)=0.0D-0
         ITER = 1
         IF (IA.NE.0) GO TO 801
!    BACK SUBSTITUTE TO GET THIS VECTOR.
790        L = N + 1
         DO 780 J=1,N
              L = L - 1
786             CONTINUE
              ELIM1=VECT(L,I)-VECT(L+1,I)*B(L,3)-VECT(L+2,I)*B(L,4)
!    IF OVERFLOW IS CONCEIVABLE, SCALE THE VECTOR DOWN.
!    THIS APPROACH IS USED TO AVOID MACHINE-DEPENDENT AND SYSTEM-
!    DEPENDENT CALLS TO OVERFLOW ROUTINES.
              IF(DABS(ELIM1) .GT. DELBIG)GO TO 782
              TEMP = B(L,2)
              IF(DABS(B(L,2)) .LT. DELTA)TEMP=DELTA
              VECT(L,I) = ELIM1/TEMP
              GO TO 780
!    VECTOR IS TOO BIG.  SCALE IT DOWN.
782             DO 784 K=1,N
784             VECT(K,I) = VECT(K,I)/DELBIG
              GO TO 786
780        CONTINUE
         GO TO (820,800), ITER
!    SECOND ITERATION.  (BOTH ITERATIONS FOR REPEATED-ROOT VECTORS).
820        ITER = ITER + 1
890        ELIM1 = VECT(1,I)
         DO 830 J=1,NM1
              IF (B(J,2).EQ.B(J,1)) GO TO 840
!    CASE ONE.
              VECT(J,I) = ELIM1
              ELIM1 = VECT(J+1,I) - ELIM1*B(J,5)
              GO TO 830
!    CASE TWO.
840             VECT(J,I) = VECT(J+1,I)
              ELIM1 = ELIM1 - VECT(J+1,I)*TEMP
830        CONTINUE
         VECT(N,I) = ELIM1
         GO TO 790
!    PRODUCE A RANDOM VECTOR
801        CONTINUE
         DO 802 J=1,N
!    GENERATE PSEUDORANDOM NUMBERS WITH UNIFORM DISTRIBUTION IN (-1,1).
!    THIS RANDOM NUMBER SCHEME IS OF THE FORM...
!    RAND1 = AMOD((2**12+3)*RAND1,2**23)
!    IT HAS A PERIOD OF 2**21 NUMBERS.
              RAND1=DMOD(4099.0D0*RAND1,RPOWER)
802       VECT(J,I)=RAND1/RPOW1-1.0D0
         GO TO 790
!
!    ORTHOGONALIZE THIS REPEATED-ROOT VECTOR TO OTHERS WITH THIS ROOT.
800        IF (IA.EQ.0) GO TO 885
         DO 860 J1=1,IA
              K = I - J1
              TEMP=0.0D0
              DO 870 J=1,N
870             TEMP = TEMP + VECT(J,I)*VECT(J,K)
              DO 880 J=1,N
880             VECT(J,I) = VECT(J,I) - TEMP*VECT(J,K)
860        CONTINUE
885        GO TO (890,900), ITER
!    NORMALIZE THE VECTOR
900       ELIM1=0.0D0
         DO 904 J=1,N
904       ELIM1=DMAX1(DABS(VECT(J,I)),ELIM1)
         TEMP=0.0D-0
         DO 910 J=1,N
              ELIM2=VECT(J,I)/ELIM1
910        TEMP = TEMP + ELIM2**2
         TEMP=1.0D0/(DSQRT(TEMP)*ELIM1)
         DO 920 J=1,N
              VECT(J,I) = VECT(J,I)*TEMP
              IF(DABS(VECT(J,I)) .LT. DEL1)VECT(J,I)=0.0D0
920        CONTINUE
700   CONTINUE
!
!    SIMVEC SECTION.
!    ROTATE CODIAGONAL VECTORS INTO VECTORS OF ORIGINAL ARRAY
!    LOOP OVER ALL THE TRANSFORMATION VECTORS
    IF (NM2.EQ.0) GO TO 1002
    JUMP = NSIZE - (N+1)
    IM = NM1
    DO 950  I=1,NM2
         J1 = JUMP
!    MOVE A TRANSFORMATION VECTOR OUT INTO BETTER INDEXING POSITION.
         DO 955  J=IM,N
              B(J,2) = A(J1)
955        J1 = J1 + J
!    MODIFY ALL REQUESTED VECTORS.
         DO 960  K=1,NROOT
              TEMP=0.0D0
!    FORM SCALAR PRODUCT OF TRANSFORMATION VECTOR WITH EIGENVECTOR
              DO 970  J=IM,N
970             TEMP = TEMP + B(J,2)*VECT(J,K)
              TEMP = TEMP + TEMP
              DO 980  J=IM,N
980             VECT(J,K) = VECT(J,K) - TEMP*B(J,2)
960        CONTINUE
         JUMP = JUMP - IM
950   IM = IM - 1
1002  CONTINUE
!    RESTORE ROOTS TO THEIR PROPER SIZE.
    DO 95 I=1,NROOT
95    ROOT(I) = ROOT(I)*ANORM
1001  RETURN
    END SUBROUTINE GIVENS